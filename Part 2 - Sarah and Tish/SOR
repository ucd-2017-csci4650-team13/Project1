% SOR Successive Over-Relaxation Method
%   This function solves linear equation systems such as Ax=b using SOR 
%   method (Successive Over-Relaxation).
%   When the relaxation scalar w = 1, the method used is Gauss-Seidel.
% Input: A = matrix A 
%        xold = initial x vector 
%        b = solution vector
%        w = relaxation parameter
%        max_it = maximum iterations
%        tol = tolerance

% Output: x = solution
%   error = relative forward error
%   iter = number of iterations
%   boolean flag = 1 means divergence, 0 means convergence

clc;
clear all;
close all;

% input initialization
A = [3 1 -1; 
     2 4 1; 
    -1 2 5];

[n, n] = size(A);

xold = [0; 0; 0];
b = [4; 1; 1];
w = 1.25;
max_it = 2;
tol = 0.00000001;
x = xold;
diagonalDominant = true;

if (w == 1)
    fprinf('The relaxation scalar omega = 1. The method used is now Gauss-Seidel')
end
   
% check for diagonally dominant convergence guarantee
for r=1:n 
    % Sum of the entire row minus the diagonal
    rowSum = sumabs(A(r,:)) - abs(A(r, r)); 
    % Check if diagonal is strictly greater than the row sum
    if (abs(A(r,r)) < rowSum)
    % If not, note it
        diagonalDominant = false;           
        break;
    end
end

if (diagonalDominant == false)
% Let user know that convergence is not guaranteed
    fprintf('Matrix A is not strictly diagonal dominant and may not converge.\n');
end

if size(b) ~= size(xold)
    error('The given approximation vector does not match the x vector size');
end

%function[x, error, iter, flag]  = sor_(A, xold, b, w, max_it, tol)
flag = 0;    
iter = 0;
count = 1;
max_it = 2;

% matrix splitting 
D = diag(diag(A));
L = tril(A-D);
U = triu(A-D);
M = D + w*L;
N = (1 - w)*D - w*U;
G = M\N;
% (inv(D+w*L))*(((1-w)*D-w*U)*x0 +w*b)
datasave = [];
% begin iteration
for iter = 1:max_it                         
        xnew = G;
        RelForError = (norm(xnew-xold))/(norm(xnew));
        % update approximation
        while (RelForError > tol)
            xold = xnew;
            M = D + w*L;
            N = (1 - w)*D - w*U;
            G = M\N*xold + w*b;
            xnew = G;
            RelForError = (norm(xnew-xold))/(norm(xnew));
            if (RelForError <= tol)
                break
            end
            count = count+1;
            x = [x, xnew];
            datasave = [datasave; count, RelForError, flag];
        end
end
%end
    b = b / w % vector b
    if (RelForError > tol) 
       flag = 1;
       fprintf('Did not converge')
   end
        
   % for function return
   x = xnew;
   error = RelForError;
   iter = count;
        
fprintf('  iteration    error    flag\n')
disp(datasave)
fprintf(' x matrix final\n')
disp(xnew)
