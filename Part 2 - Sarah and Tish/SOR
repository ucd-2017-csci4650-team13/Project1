clc;
clear all;
close all;

% input initialization
A = [3 1 -1; 
     2 4 1; 
    -1 2 5]

[n, n] = size(A)

xold = [0; 0; 0];
b = [4; 1; 1];
w = 1.25;
max_it = 2;
tol = 0.00000001;
x = xold;
diagonalDominant = true;

% TODO: check omega for over/under/Gaussian relaxation
% check for diagonally dominant convergence guarantee
for r=1:n 
    % Sum of the entire row minus the diagonal
    rowSum = sumabs(A(r,:)) - abs(A(r, r)); 
    % Check if diagonal is strictly greater than the row sum
    if (abs(A(r,r)) < rowSum)
    % If not, note it
        diagonalDominant = false;           
        break;
    end
end

if (diagonalDominant == false)
% Let user know that convergence is not guaranteed
    fprintf('Matrix A is not strictly diagonal dominant and may not converge.\n');
end

if size(b) ~= size(xold)
    error('The given approximation vector does not match the x vector size');
end

%function[x, error, iter, flag]  = sor_(A, xold, b, w, max_it, tol)
flag = 0;    
iter = 0;
count = 1;
max_it = 2;

% matrix splitting 
D = diag(diag(A));
L = tril(A-D);
U = triu(A-D);
M = D + w*L;
N = (1 - w)*D - w*U;
G = M\N;
% (inv(D+w*L))*(((1-w)*D-w*U)*x0 +w*b)
% begin iteration
for iter = 1:max_it                         
        xnew = G
        RelForError = (norm(xnew-xold))/(norm(xnew))
        % update approximation
        while (RelForError > tol)
            xold = xnew
            M = D + w*L
            N = (1 - w)*D - w*U
            G = M\N*xold + w*b
            xnew = G
            RelForError = (norm(xnew-xold))/(norm(xnew))
            if (RelForError <= tol)
                break
            end
            count = count+1;
            x = [x, xnew]
        end
        disp(x)
        
        if (RelForError > tol) 
            flag = 1;
            fprintf('Did not converge')
        end
        
        % for function return
        x = xnew
        error = RelForError
        iter = count
end
%end
